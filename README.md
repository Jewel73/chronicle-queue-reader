# Chronicle Queue Reader library

**Chronicle Log Reader** is a Java library tailored to efficiently read log data generated by Java applications and stored in a [Chronicle Queue](https://github.com/OpenHFT/Chronicle-Queue) in binary format. This library provides methods to decode log messages, process logs, and seamlessly retrieve log data from a Chronicle Queue.

## Table of Contents

- [Prerequisites](#prerequisites)
- [Getting Started](#getting-started)
  - [Installation](#installation)
  - [Configuration](#configuration)
- [Usage](#usage)
  - [Reading Logs](#reading-logs)
  - [Customization](#customization)
- [Contributing](#contributing)


## Prerequisites

Before using this service, ensure you have the following prerequisites:

- Java Development Kit (JDK) installed (Java 17).
- [Spring Framework](https://spring.io/) for dependency injection (used in this example).
- [Chronicle Queue](https://github.com/OpenHFT/Chronicle-Queue) library.

## Getting Started

### Installation

1. Clone this repository to your local machine:


   git clone https://github.com/yourusername/your-repo.git
   

2. Build the project using a Java build tool like [Maven](https://maven.apache.org/):


   mvn clean install
   
# Running Chronicle Queue Log Reader

To run the Chronicle Queue Log Reader JAR with Java 11 or later, you'll need to include additional VM (Virtual Machine) or command-line arguments. Here's the complete command to run the JAR:

```shell
java --add-exports=java.base/jdk.internal.ref=ALL-UNNAMED \
     --add-exports=java.base/sun.nio.ch=ALL-UNNAMED \
     --add-exports=jdk.unsupported/sun.misc=ALL-UNNAMED \
     --add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
     --add-opens=jdk.compiler/com.sun.tools.javac=ALL-UNNAMED \
     --add-opens=java.base/java.lang=ALL-UNNAMED \
     --add-opens=java.base/java.lang.reflect=ALL-UNNAMED \
     --add-opens=java.base/java.io=ALL-UNNAMED \
     --add-opens=java.base/java.util=ALL-UNNAMED \
     -jar chronicle-queue-log-reader-0.0.1-SNAPSHOT.jar
```
### Configuration

In order to use the CustomLogReaderService, you need to configure it with the appropriate settings. Edit the application.properties (or application.yml) file to specify the following configuration properties:

properties
base.queue.path=PATH_TO_YOUR_CHRONICLE_QUEUE
queue.topic=YOUR_QUEUE_TOPIC_NAME
queue.start.cycle=START_CYCLE_NAME_OR_DATE


- `base.queue.path`: The base path to your Chronicle Queue.
- `queue.topic`: The name of the queue topic you want to read logs from.
- `queue.start.cycle`: The cycle to start reading logs from (use `TODAY` for today's logs or provide a specific date in the format defined in `QueueConstant.TIME_FORMAT`).

## Usage

### Reading Logs

To read logs from the Chronicle Queue, you can use the `CustomLogReaderService` class. Here's how to do it:
```
java
import com.naztech.logreader.service.CustomLogReaderService;
import com.naztech.logreader.processor.LogProcessor;

// Instantiate the CustomLogReaderService
CustomLogReaderService logReaderService = new CustomLogReaderService("PATH_TO_YOUR_CHRONICLE_QUEUE", "YOUR_QUEUE_TOPIC_NAME", "START_CYCLE_NAME_OR_DATE");

// Implement a custom LogProcessor to handle log messages
LogProcessor logProcessor = (logMessage) -> {
    // Your custom processing logic here
    System.out.println(logMessage.toString());
};

try {
    // Read logs and process them
    logReaderService.readLogs(logProcessor, true);
} catch (Exception e) {
    e.printStackTrace();
}
```

### Customization

You can customize the behavior of the `CustomLogReaderService` by modifying its methods and properties. Here are some customization options:

- Adjust the `RollCycles` used for Chronicle Queue rollover.
- Customize log message processing in the `LogProcessor` implementation.
- Handle errors and exceptions based on your application's requirements.

## Contributing

If you would like to contribute to this project or report issues, please follow these steps:

1. Fork the repository.
2. Create a new branch with your feature or bug fix.
3. Make your changes and commit them.
4. Push the changes to your fork.
5. Submit a pull request to the original repository.

